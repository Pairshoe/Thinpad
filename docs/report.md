<font face="宋体">

# <center>计算机组成原理 流水线实验 报告</center>
<center>罗富文  计91  2019011409 &nbsp; 刘家宏  计94  2019011297 &nbsp; 王拓为  计94  2018011917</center>

<br><br>

## 1. 实验目标（lfw）

## 2. 实验内容
### 2.1. 流水线（lfw）

### 2.2. 流水线冲突与优化（lfw）

### 2.3. SRAM 与 UART （lfw）

### 2.4. 中断与异常（ljh）

中断和异常部分主要有以下任务：1.解析一些特权指令；2.实现csr寄存器和mmio寄存器的读写；3.根据指令和寄存器的实现相应修改数据通路；4.根据监控程序的需求在流水线中处理中断和异常。主要涉及的文件有：`alu.h`，`alu.vh`，`csr_index.vh`，`csr_regfile.v`，`decoder.v`，`exception_interrupt.vh`，`pipeline.v`，`sram.v`。

需要解析的指令包括CSRRC、CSRRS、CSRRW、EBREAK、ECALL、MRET、SLTU。SLTU为常规指令，EBREAK、ECALL、MRET只需要让流水线得知即可，不需要特殊处理，这四条指令只需要修改decoder。CSRR系列指令比较麻烦，同时涉及到普通寄存器和csr寄存器的读写及运算。为此在流水线中增加控制信号，将普通寄存器和csr寄存器值都输入alu运算，并**另开一条通路用于csr寄存器写入**，此外还要将其**并入数据旁路**。

csr寄存器存储在`csr_regfile.v`中。这一部分实际上只实现了mtvec、mscratch、mepc、mcause、mstatus、mie、mip、mtval这8个寄存器。设置两种读写方式：普通读写和专用读写。普通读写是通过**csr寄存器索引值**来读写，若索引值有效（是实现的8个寄存器之一）则读写有效，若索引值无效则读为0、写弃置。专用读写将实现的8个寄存器**分别接线**到流水线中，方便流水线对中断和异常的处理。同时，区分普通和专用也是考虑到CSRR系列指令对csr寄存器的读写和中断异常处理对csr寄存器的读写**可能的冲突**。为了保存当前所在的特权状态（U/M/S），增加一个**mode寄存器**，通过专用读写线连到流水线中。

mmio寄存器并入`sram.v` 处理，在mem阶段读写，**类似于对串口状态位的处理**，特判地址即可。mtime的更新也在`sram.v`中完成，在用户态下默认每两个时钟周期加一。

监控程序需要实现的异常有：U态ecall、U态ebreak；需要实现的中断只有时钟中断。时钟中断的**优先级最高**，由`sram.v`内部进行超时的检测，向流水线发出**超时信号**。流水线检测到超时后立即暂停流水线，跳转到异常处理地址，并设置mcause、mstatus、mepc和mode。由于监控程序在检测到M态时钟中断后会直接返回，故默认只有U态才会发生时钟中断。ecall和ebreak在**id阶段的一开始**就可以检测到并开始处理，同样是暂停流水线、跳转、设置csr寄存器和mode。mret与ecall和ebreak同级检测，区别只是mret跳转到mepc对应的地址，以及寄存器写入的值不同而已。

### 2.5. 页表与 TLB （wtw）

### 2.6. cache（lfw）

### 2.7. VGA （ljh）

VGA部分主要有以下任务：1.控制vga的输出显示；2.使用bram作为显存完成实时读写；3.实现拓展功能的逻辑。主要涉及的文件有：`vga.v`，`bram.v`。

vga的基本控制逻辑已经在示例代码中给出，需要完成的实际上是在**输入横坐标hdata和纵坐标vdata时，输出确定的颜色组合**（video_red、video_green、video_blue）。为此，开出模块`vga.v`和`bram.v`，在`vga.v`中输出hdata和vdata并输入到`bram.v`，在`bram.v`中使用组合逻辑输出颜色值。

显存使用bram而非sram，一方面是因为bram读写效率更高，另一方面是防止内存数据冲突。实验用的FPGA板上提供了多种可直接实例化的bram，`bram.v`中使用**xpm_memory_tdpram**，它有**两个独立的读写端口**。在实现中，**B端口只使用读功能**，通过特定的组合逻辑将输出的**横纵坐标映射为读取的地址**，将读出的数据输出，这便实时给出了vga显示需要的数据。**A端口可读可写**，用于拓展功能的逻辑实现。由于一个颜色组合恰好可用8位来唯一确定，故bram的**数据位宽就设置为8位**，另外地址位宽设置为14位可以保证拓展功能的空间足够。

**扩展功能1是寄存器值显示**。即通过拨码开关显示当前32个寄存器中任意一个寄存器的值。首先，获取0到f的点阵字体，将其存入到数据文件中并作为bram的MEMORY_INIT_FILE，这样**点阵数据就存到了bram中**。其次，通过在将寄存器值和拨码开关的数据接入到bram中，再将B端口的**读取地址映射到对应的点阵字体**，这样就实现了显示。

**扩展功能2是可控制的康威生命游戏**。康威生命游戏是一个基于离散方格图的状态机，它下一时刻的状态仅由当前时刻状态决定。最终版本可以用特定程序和拨码开关控制一个16*16大小的生命游戏的启动与暂停，同时可以用拨码开关控制在其中任意一个位置进行死、活细胞状态的修改。生命游戏的介绍可参考[Conway's Game of Life - LifeWiki (conwaylife.com)](https://www.conwaylife.com/wiki/Conway's_Game_of_Life)。

实现该功能的基本思路仍然是**外部信号的接入**和**bram特定地址的读写**。此处16*16的空间映射到bram中一段连续的地址中，读写对应的都是这一段地址。在暂停状态下，细胞状态的修改实际上就是用**A端口对由拨码开关确定的地址进行写入**。在启动状态下，每隔0.5s（25M个时钟周期），会根据生命游戏规则进行一次状态转换，这是通过**A端口一系列连续读写**实现。启动和暂停的控制是通过检测拨码开关值和cpu发来的信号值实现的。cpu的信号由**检测decoder的两个特殊指令值**确定，这样如果**将特殊的指令写成汇编程序，就可以通过执行这个程序来控制生命游戏的启动和暂停**。

## 3. 效果展示（ljh）

### 3.1 基础功能及其优化

用终端连接在线平台的实验板，运行基础版本的监控程序，依次执行5个性能测试程序。在此处可以看到流水线的优化和cache的效果：

<img src="images\3.1.png" alt="3.1" style="zoom:50%;" />

同时，在线功能测试保证了基础版本执行的正确性：

<img src="images\3.2.png" alt="3.2" style="zoom: 50%;" />

### 3.2 中断和异常

再改用页表版本监控程序（含中断异常），运行以下汇编测例：

1.测试ebreak的正确性。在汇编程序的一开始就进行ebreak，程序应当立即执行完毕，如下图：

<img src="images\3.3.png" alt="3.3" style="zoom:50%;" />

2.测试ecall的正确性。汇编程序由一系列的ecall组成，最后会正常返回。最终运行表现为输出一个字符串：

<img src="images\3.4.png" alt="3.4" style="zoom:50%;" />

3.测试时钟中断。汇编程序只有一行，为一个不断原地跳转的死循环。cpu最终在0.4s后杀掉了程序，说明时钟中断表现正确：

<img src="images\3.5.png" alt="3.5" style="zoom:50%;" />

4.ecall+时钟中断。在输出字符串后进入死循环。表现出来为程序输出一段字符串之后被杀掉：

<img src="images\3.6.png" alt="3.6" style="zoom:50%;" />

### 3.3 页表和TLB

继续使用页表版本监控程序。设置一个测例：进行一系列ecall，然后正常返回。将该测例读入到不同物理地址并运行，可以确认页表映射的正确性。

1.放置到物理地址0x80100000，分别在虚拟地址0x00000000和0x80100000运行：

<img src="images\3.8.png" alt="3.8" style="zoom:50%;" />

<img src="images\3.7.png" alt="3.7" style="zoom:50%;" />

2.放置到物理地址0x803f0000，在虚拟地址0x002f0000运行：

<img src="images\3.9.png" alt="3.9" style="zoom:50%;" />

<img src="images\3.10.png" alt="3.10" style="zoom:50%;" />

3.放置到物理地址0x80400000，在虚拟地址0x7fc10000运行：

<img src="images\3.11.png" alt="3.11" style="zoom:50%;" />

<img src="images\3.12.png" alt="3.12" style="zoom:50%;" />

4.放置到物理地址0x807e0000，在虚拟地址0x7fff0000运行：

<img src="images\3.13.png" alt="3.13" style="zoom:50%;" />

<img src="images\3.14.png" alt="3.14" style="zoom:50%;" />

### 3.4 VGA及其拓展功能

如下图，左边为DVI输出，上方为寄存器值显示，下方为康威生命游戏显示。右边为命令行，读入了控制康威生命游戏启动/暂停的两个程序。

<img src="images\3.15.png" alt="3.15" style="zoom:50%;" />

通过执行两个程序及控制拨码开关，可以控制上方数字显示不同寄存器的值，及对生命游戏进行读写、启动和暂停操作，以改变其状态。

<img src="images\3.16.png" alt="3.16" style="zoom:50%;" />



## 4. 实验心得体会（wtw）

## 5. 遇到的困难与解决方案（lfw）

## 6. 设计框图（wtw）

## 7. 数据通路图（wtw）

## 8. 思考题
### 8.1. （lfw）

### 8.2. （wtw）

### 8.3. （ljh）

**如何将DVI作为系统的输出设备，从而在屏幕上显示文字？**

首先，需要根据DVI的参数，对应设置一个能与时钟同步的逐像素扫描控制器。它每个时钟周期输出一个确定的横纵坐标、横纵同步信号以及有效位。扫描控制器可以逐行扫描或逐列扫描。其次，对于有效的横纵坐标，需要即时（组合逻辑）确定R、G、B三种颜色的值并输出到DVI。完成这两点后，DVI就可以同步显示出图像。

如果需要显示特定的文字，首先需要设置一段显存空间，至少要求是可读的。其次，将需要使用的文字组织为点阵字体文件，连续地合并到一个文件中（一般为.mem格式），并将此文件作为显存的初始化文件，这样文字数据就保存在了显存中。在需要显示时，将扫描控制器给出的横纵坐标映射到特定的地址，读取对应的显存数据并输出。

## 9. 致谢（lfw）



## PPT: 数据通路图 设计框图 VGA 动态分支预测 cache 遇到的困难 心得体会
