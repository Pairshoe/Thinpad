<font face="宋体">

# <center>计算机组成原理 流水线实验 报告</center>
<center>罗富文  计91  2019011409 &nbsp; 刘家宏  计94  2019011297 &nbsp; 王拓为  计94  2018011917</center>

<br><br>

## 1. 实验目标

 - 深入理解流水线结构计算机指令的执行方式，掌握流水处理器的基本设计方法。
 - 深入理解计算机的各部件组成及内部工作原理，掌握计算机外部输入输出的设计。
 - 加深对于 RISCV-32I 指令集的理解。
 - 提高硬件设计和调试的能力。

## 2. 实验内容

### 2.1. 流水线

本次实验中，流水线共分为 5 个阶段，分别为 IF 取指、 ID 译码、 EXE 执行、 MEM 访存和 WB 写回，每条指令依次经过 5 个阶段完成执行。在流水线不断流的情况下，同时有 5 条指令被执行。

#### 2.1.1. 指令在不同阶段之间的传递

指令在不同阶段之间的传递主要通过阶段寄存器进行。每两个阶段之间均存在若干阶段寄存器，用于记录上一个阶段的运算结果中对本阶段及以后的阶段有用的数据。一个阶段在执行时，从其与上一阶段之间的阶段寄存器读取数据并执行操作，并将需要传递给下一阶段的结果写入其与下一阶段之间的阶段寄存器。

在本次实验中，我们组采用计数器和 `done` 信号相结合的方式控制指令的传递。为了处理流水线冲突和生成各种控制信号，每一阶段的第 0 周期均不执行任何计算操作，该周期保留给 controller 使用。除此以外， ID 和 EXE 阶段由纯组合逻辑实现，需 1 个周期完成； WB 阶段有写寄存器操作，需要 2 个周期完成； IF 和 MEM 阶段需要访存，由于页表、 TLB 、 Cache 等机制的存在，其执行周期数不固定。另外，为了编程方便，我们选择等待所有阶段执行完毕后统一进行指令的传递。综上所述，我们在流水线中引入了计数器 `counter` ，每一阶段开始时将其置 0 ，每经过 1 周期其计数增加 1 ；另外，我们在 SRAM 模块增加 `done` 信号。当流水线识别到计数器的值大于 2 且 `done` 信号值为 1 时，其传递指令并开启下一阶段的执行。

#### 2.1.2. 气泡的插入与指令的废除

为了方便处理流水线冲突，我们设置了一个特别的阶段寄存器 `abort` ，并为每一阶段设置了暂停信号 `stall` 。 `abort` 寄存器记录该指令是否被废除，当其值为 1 时，该阶段不进行任何操作（相当于执行 `nop` 指令）。 `stall` 信号用于暂停某几个阶段的执行，受流水线结构特点的限制，被暂停的阶段必须是连续的且 IF 阶段必须被包括在内。

插入气泡时， `stall` 信号为 1 的阶段均不执行操作，系统在最后一个被暂停的阶段与第一个未被暂停的阶段之间插入一条指令，其 `abort` 寄存器的值为 1 ；废除指令时，只需将需要废除的指令对应的 `abort` 寄存器的值置为 1 即可。

### 2.2. 流水线冲突处理

对流水线冲突的处理工作主要由 controller 完成，其在每个阶段的第 0 周期生成信号对流水线进行控制。

#### 2.2.1. 控制冲突处理：动态分支预测

流水线执行过程中遇到 B 型指令或 J 型指令时可能发生跳转，但执行跳转操作时该指令已完成 EXE 阶段，此时处于 IF 和 ID 阶段的指令不应被执行，这就产生了控制冲突。

我们采用动态分支预测的方法解决冲突。我们采用 32 项预测表，用直接映射的方法读写表项。需要注意的是，本次实验中采用 32 位地址，指令地址是 4 字节对齐的，所以我们用地址的第 2 - 6 位而不是 0 - 4 位进行映射。当发生跳转时，预测表中会记录跳转指令的地址和跳转目的地址，下次执行至该位置时即预测跳转， IF 阶段结束后把 pc 指针设置为目的地址；当预测跳转失败时，从表中删除该项。

需要注意的是，当预测跳转失败或未成功预测跳转时，需要把位于 IF 和 ID 阶段的指令废除，将其 `abort` 寄存器的值置为 1 。

#### 2.2.2. 数据冲突处理：数据旁路

在本实验中，仅存在 Read After Write 型数据冲突，即需要从寄存器中读出的值在 ID 阶段尚未写入寄存器。对此，需要分如下几种情况处理。

 - 若写寄存器的指令类型为 LOAD ，则无法进行数据前传。这种情况下冲突的解决方法为暂停 IF 和 ID 阶段流水线的运行直至该指令访存完毕；
 - 若写寄存器的指令位于 EXE 阶段，则将 EXE 阶段的计算结果前传至 ID 阶段；
 - 若写寄存器的指令位于 MEM 阶段，则将 MEM 阶段对应阶段寄存器的值前传至 ID 阶段。

需要注意的是，数据冲突优先级低于控制冲突，若发生控制冲突则无需处理数据冲突。

#### 2.2.3. 结构冲突处理

结构冲突指 IF 和 MEM 阶段需要同时访存而导致冲突。此时只需暂停 IF 阶段流水线的运行直至 MEM 阶段访存完毕即可。

### 2.3. SRAM 与 UART

SRAM 与 UART 的功能由同一模块完成。该模块中还集成了 Cache 、页表和 TLB 等功能。其中页表和 TLB 将在 2.5 节作详细说明。

#### 2.3.1. SRAM 与 UART 时序

SRAM 和 UART 由一个状态机控制，状态机各状态如下所示。

 - IDLE ：闲置状态。当不对 SRAM 或 UART 进行读写时，状态机处于该状态。每个时钟周期上升沿到来时，该模块检测 oe 或 we 信号是否为高电平。若信号为高电平则根据 oe / we 信号和地址 address 进入 SRAM_READ 、 SRAM_WRITE 、 UART_READ 、 UART_WRITE 等状态。需要注意的是，对于 UART 读写状态位等 MMIO ，其值由寄存器而不是 SRAM 保存，因此无需进入上述状态而直接进入 FINISHED 状态。
 - SRAM_READ ：读内存状态。把 base_ram_oe_n 或 ext_ram_oe_n 拉低并从内存中读数。
 - SRAM_WRITE ：写内存状态。把 base_ram_we_n 或 ext_ram_we_n 拉低并向内存中写数。
 - UART_READ ：读串口状态。把 uart_rdn 拉低并读取数据。需要注意的是，若读取数据前 dataready 不为 1 则不能读出正确的数据。
 - UART_WRITE ：写串口状态。把 uart_wrn 拉低并向串口写数据。
 - FINISHED ：完成状态。拉高所有控制信号并输出 done 信号。

#### 2.3.2. UART 读写状态位的控制

对于 UART 读状态位，当 dataready 信号为高电平且 SRAM 模块处于闲置状态时即可将其置 1 。

对于 UART 写状态位，需要在向 UART 写入数据后等待 tbre 信号变为高电平，然后再等待 tsre 信号变为高电平后放可将其置 1 。为此，需要一个单独的状态机对写状态位进行控制。

#### 2.3.3. Cache

在本次实验中我们的 Cache 表共 32 项，由寄存器实现，每项中记录了数据的物理地址和 4 字节的数据。 Cache 采用直接映射的方式设计，由于每项共 4 字节数据，所以我们用地址的第 2 - 6 位而不是 0 - 4 位进行映射。读写 Cache 的具体过程如下。

 - 读 Cache ：当 SRAM 模块主状态机为 IDLE 状态且检测到 oe 信号为高电平时，尝试将地址 address 与 Cache 表中对应项的地址进行比对，若表项有效且地址相同则直接输出对应的值，进入 FINISHED 状态，否则进入 SRAM_READ 或 UART_READ 状态。
 - Cache 表项更新：当 SRAM 模块主状态机为 SRAM_READ 状态时，说明发生了 Cache Miss 且正在从内存中读取数据。此时根据地址 address 和读取的数据值对表项进行覆盖即可。
 - 数据写入：采用 Write Through 模式。当 SRAM 模块主状态机为 IDLE 状态且检测到 we 信号为高电平时，尝试将地址 address 与 Cache 表中对应项的地址进行比对，若地址相同则对表项进行覆盖，同时进入 SRAM_WRITE 状态；否则无需更新 Cache 表，直接进入 SRAM_WRITE 或 UART_WRITE 状态。

### 2.4. 中断与异常（ljh）

### 2.5. 页表与 TLB （wtw）

### 2.6. VGA （ljh）

## 3. 效果展示（ljh）

## 4. 实验心得体会（wtw）

## 5. 遇到的困难与解决方案

在本次实验中，我们遇到的最大困难为程序在通过功能仿真和后仿真的情况下无法稳定通过自动化测试。经过调试，可能是如下问题导致的。

 - 程序中出现大段组合逻辑，生成电路过于复杂，导致时延较大。
 - 程序中存在过深的 if - else 嵌套，导致时延较大。
 - 部分状态机由于某些未知原因，在后仿真时报 timing violation 错误。

为了提高程序稳定性，我们采取了如下策略。

 - 拆分或简化组合逻辑，避免过大的组合逻辑电路。
 - 削减 if - else 嵌套，必要时增加时钟周期数以保证逻辑电路的稳定运行。
 - 简化或重写状态机以避开出问题的寄存器。

经实测检验，上述方法能有效提升程序稳定性，使程序稳定通过自动化测试。虽然该问题与代码逻辑实现无关，甚至一部分造成错误的原因无法解释，但是对程序逻辑的简化确实能起到提升程序稳定性的效果。这说明硬件编程时我们需要多注意代码的简洁性，避免代码过于冗长。

## 6. 设计框图（wtw）

## 7. 数据通路图（wtw）

## 8. 思考题

### 8.1. 流水线 CPU 设计与多周期 CPU 设计的异同？插入等待周期（气泡）和数据旁路在处理数据冲突的性能上有什么差异。

流水线 CPU 与多周期 CPU 设计的相同点是均需设计 5 个 Stage ，与内存、串口等模块的交互也是类似的。不同点在于流水线 CPU 需要使用阶段寄存器传递各阶段的运算结果，且由于不同阶段同时执行，需要处理控制冲突、数据冲突、结构冲突等。

数据旁路在发生冲突的写寄存器指令非读内存或串口类型的指令时可以通过数据前传的方式在不打断流水线的情况下保证程序运行的正确性，而插入等待周期会导致流水线中断。因此，数据旁路相较插入等待周期的方法在处理数据冲突时性能更优。

### 8.2. （wtw）

### 8.3. （ljh）

## 9. 致谢

由于我们组在造机过程中遇到问题较多，所以经常找老师和助教答疑。在老师和助教的指导下，我们的硬件编程和调试能力有了显著的提高。感谢老师和助教对我们组问的问题的耐心解答和对我们组的悉心指导！

## PPT: 数据通路图 设计框图 VGA 动态分支预测 cache 遇到的困难 心得体会（wtw）
